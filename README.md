### 4 Preguntas de Pensamiento Crítico
## Memoria: ¿Por qué usar apuntadores reduce 75% de memoria con 10M registros?
Al usar apuntadores en vez de copiar los elementos varias veces, logramos reducir la memoria ya que los apuntadores a comparación de los objetos o structs personas siempre ocupa 8 bytes, mientras que hacer una copia de persona al guardar varios campos de multiples bytes ocupa más espacio en memoria.
## Datos: Si el calendario depende de dígitos del documento, ¿cómo optimizar búsquedas por grupo?
Ya que las busquedas de personas por grupo puede ser una operación que es probable que se repita más de una vez lo mejor es precalcular el grupo y guardarlo en un atributo de la persona, asi sacrificamos más uso de memoria a cambio de velocidad en la ejecución del código, esto nos permite acceder al grupo de cada persona accediendo a un atributo y no calcularlo cada que queramos ver los grupos de todas las personas.


## Localidad: ¿Cómo afecta el acceso a memoria al usar array de structs vs. vector de clases?

El acceso a las variables guardadas dentro de un array tanto como en un vector es igual, ya que ambas estructuras acceden a sus elementos a traves de aritmetica de punteros, por lo cual en ambos esta operación es constante O(1), la diferencia entre ambas estructuras de datos es que por lo general los arrays se guardan en la memoria stack(excepto si se inician con la palabra new), mientras que los vectores se guardan en la memoria heap. La diferencia entre los structs y las clases es el acceso a los atributos. En las structs los atributos son publicos, mientras que en las clases son privados y se utilizan getters y setters para acceder a dichos atributos, lo cual puede hacer que las clases ocupen un poco mas de memoria que las structs. 

## Escalabilidad (Consulta): Si los datos exceden la RAM, ¿cómo usar mmap o memoria virtual?
Cuando los datos exceden la RAM, usar (mmap) o memoria virtual, que permite mapear un archivo en el espacio de direcciones del proceso como si fuera un array en memoria; de esta forma, el sistema operativo solo carga en RAM las páginas del archivo que realmente se acceden, evitando cargar todo de una vez. Esto reduce el consumo de memoria, evita copias innecesarias a buffers intermedios y permite trabajar con archivos muy grandes (decenas de GB) sin sobrepasar la RAM, siempre que los accesos estén organizados (preferiblemente secuenciales) para minimizar page faults y no caer en thrashing. El flujo típico es abrir el archivo con open(), obtener su tamaño con fstat(), y luego mapearlo en memoria con mmap(), que devuelve un puntero void* al inicio del área mapeada. Ese puntero puede reinterpretarse como el tipo de dato deseado (por ejemplo, char* para recorrer el archivo como un arreglo de caracteres). Una vez mapeado, se accede al contenido como si fuera un array en RAM, pero en realidad el SO gestiona la carga de las páginas necesarias desde disco. Finalmente, se libera con munmap() y se cierra el descriptor de archivo. En proyectos modernos de C++, se suelen encapsular estas llamadas en clases RAII para asegurar el cierre y liberación correctos sin fugas de recursos.
